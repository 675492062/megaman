Before submission: 

* benchmarking (plots of time vs. ...)
    * C++ distance
        * N (update auto in distance_matrix)
        * D
        * radius
    * Embedding
        * N
        * radius

* test functions (check for Sklearn imports and then run those tests)
    * embedding/
        * isomap.py ( check inputs )  -- look @ sklearn test function 
        * ltsa.py -- null_space for different solvers, check inputs 
        * locally_linear.py -- null_space for different solvers, check inputs 
        * spectral_decomposition.py -- compare output with D's matlab
    * utils/
        * eigendecomp.py -- don't test validity of eigh, lobpcg etc just warnings, failures etc. 
    * geometry/
        * distance.py -- done 
        * geometry.py
            * affinity_matrix() -- test_laplacian might have some testing for this? Compare with rbf kernel
            * laplacian_matrix() -- a lot of testing already in test_laplacian
            * Geometry class -- test input methods, changing the laplacian etc. 

After Paper:

* Remove debugging code
* Update comments 
* C++ integration 
* Turn into package
* Complete README 

Future Work:

* Natively support k-nearest neighbors as well as radius 
* Lazy R-metric updates
* R-metric covariance plotting tool